<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor History</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .chart-container { position: relative; height: 60vh; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">

    <nav class="w-full max-w-4xl flex justify-center mb-8">
        <a href="index.html" class="bg-gray-300 text-gray-800 font-semibold py-2 px-6 rounded-l-full shadow-lg hover:bg-gray-400 transition duration-300">Latest</a>
        <a href="history.html" class="bg-blue-600 text-white font-semibold py-2 px-6 rounded-r-full shadow-lg hover:bg-blue-700 transition duration-300">History</a>
    </nav>

    <div class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-4xl text-center">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6">Historical Sensor Data</h1>
        <div class="grid grid-cols-1 gap-8">
            <div class="chart-container">
                <canvas id="temperatureChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="humidityChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="soilMoistureChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="raindropChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="accelXChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="accelYChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="accelZChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Thresholds updated for the new sensor data structure.
        // ADC sensors (raindrop, soilMoisture) use INVERSE logic: a low value is critical.
        const THRESHOLDS = {
            temperature: 40,
            humidity: 90,
            accelX: 2.5,
            accelY: 2.5,
            accelZ: 12.0,
            raindrop: 100,    // Critical when LOW
            soilMoisture: 700 // Critical when LOW
        };

        const SECONDS_TO_AVERAGE = 10;

        function averageData(data) {
            const averagedData = {};
            // Updated keys to match the new sensor fields
            const keys = ['temperature', 'humidity', 'accelX', 'accelY', 'accelZ', 'raindrop', 'soilMoisture'];

            keys.forEach(key => {
                averagedData[key] = [];
            });
            averagedData.labels = [];

            if (data.length === 0) return averagedData;

            let bucketStartTimestamp = new Date(data[0].timestamp).getTime();
            let bucket = [];

            data.forEach(reading => {
                const readingTime = new Date(reading.timestamp).getTime();
                
                if (readingTime - bucketStartTimestamp < SECONDS_TO_AVERAGE * 1000) {
                    bucket.push(reading);
                } else {
                    if (bucket.length > 0) {
                        const averagedReading = keys.reduce((acc, key) => {
                            const sum = bucket.reduce((s, r) => s + r[key], 0);
                            acc[key] = sum / bucket.length;
                            return acc;
                        }, {});

                        keys.forEach(key => {
                            averagedData[key].push({
                                x: new Date(bucketStartTimestamp),
                                y: averagedReading[key]
                            });
                        });
                        averagedData.labels.push(new Date(bucketStartTimestamp).toLocaleTimeString());
                    }

                    bucket = [reading];
                    bucketStartTimestamp = readingTime;
                }
            });

            // Process the last bucket
            if (bucket.length > 0) {
                const averagedReading = keys.reduce((acc, key) => {
                    const sum = bucket.reduce((s, r) => s + r[key], 0);
                    acc[key] = sum / bucket.length;
                    return acc;
                }, {});

                keys.forEach(key => {
                    averagedData[key].push({
                        x: new Date(bucketStartTimestamp),
                        y: averagedReading[key]
                    });
                });
                averagedData.labels.push(new Date(bucketStartTimestamp).toLocaleTimeString());
            }

            return averagedData;
        }
        
        // Added isInverse flag for ADC sensors where a lower value is critical
        function createChart(canvasId, label, data, borderColor, backgroundColor, threshold, isInverse = false) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            let backgroundColors = data.map(point => {
                if (isInverse) {
                    // If inverse, use red if value is BELOW the critical threshold
                    return point.y < threshold ? 'rgba(255, 99, 132, 0.5)' : backgroundColor;
                } else {
                    // If normal, use red if value is ABOVE the critical threshold
                    return point.y > threshold ? 'rgba(255, 99, 132, 0.5)' : backgroundColor;
                }
            });

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(p => p.x.toLocaleTimeString()),
                    datasets: [{
                        label: label,
                        data: data.map(p => p.y),
                        borderColor: borderColor,
                        backgroundColor: backgroundColor,
                        pointBackgroundColor: backgroundColors,
                        pointRadius: 5,
                        pointHoverRadius: 8,
                        fill: false,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Sensor Value'
                            },
                            beginAtZero: false // Set to false to better visualize small changes
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Main function to fetch data and create charts
        async function fetchAndPlotHistory() {
            try {
                const response = await fetch('/api/history');
                const rawData = await response.json();
                const averagedData = averageData(rawData);

                // Plot all 7 charts with specific colors and inverse logic where needed
                createChart('temperatureChart', 'Temperature (°C)', averagedData.temperature, 'rgb(255, 99, 132)', 'rgba(255, 99, 132, 0.5)', THRESHOLDS.temperature);
                createChart('humidityChart', 'Humidity (%)', averagedData.humidity, 'rgb(54, 162, 235)', 'rgba(54, 162, 235, 0.5)', THRESHOLDS.humidity);
                
                // Inverse logic (low value is critical)
                createChart('soilMoistureChart', 'Soil Moisture (ADC)', averagedData.soilMoisture, 'rgb(153, 102, 255)', 'rgba(153, 102, 255, 0.5)', THRESHOLDS.soilMoisture, true);
                createChart('raindropChart', 'Raindrop (ADC)', averagedData.raindrop, 'rgb(75, 192, 192)', 'rgba(75, 192, 192, 0.5)', THRESHOLDS.raindrop, true);
                
                // Acceleration readings
                createChart('accelXChart', 'Acceleration X (m/s²)', averagedData.accelX, 'rgb(255, 159, 64)', 'rgba(255, 159, 64, 0.5)', THRESHOLDS.accelX);
                createChart('accelYChart', 'Acceleration Y (m/s²)', averagedData.accelY, 'rgb(255, 205, 86)', 'rgba(255, 205, 86, 0.5)', THRESHOLDS.accelY);
                createChart('accelZChart', 'Acceleration Z (m/s²)', averagedData.accelZ, 'rgb(102, 255, 102)', 'rgba(102, 255, 102, 0.5)', THRESHOLDS.accelZ);


            } catch (error) {
                console.error('Error fetching and plotting data:', error);
            }
        }

        fetchAndPlotHistory();
        // Refresh the charts every minute
        setInterval(fetchAndPlotHistory, 60 * 1000);
    </script>
</body>
</html>