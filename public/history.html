<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor History</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .chart-container { position: relative; height: 60vh; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">

    <nav class="w-full max-w-4xl flex justify-center mb-8">
        <a href="index.html" class="bg-gray-300 text-gray-800 font-semibold py-2 px-6 rounded-l-full shadow-lg hover:bg-gray-400 transition duration-300">Latest</a>
        <a href="history.html" class="bg-blue-600 text-white font-semibold py-2 px-6 rounded-r-full shadow-lg hover:bg-blue-700 transition duration-300">History</a>
    </nav>

    <div class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-4xl text-center">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6">Historical Sensor Data</h1>
        <div class="grid grid-cols-1 gap-8">
            <div class="chart-container">
                <canvas id="temperatureChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="humidityChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="soil_moistureChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="rain_statusChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="vibrationChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="accel_xChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="accel_yChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="accel_zChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="gyro_xChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="gyro_yChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="gyro_zChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Thresholds updated for all 11 sensor data fields.
        const THRESHOLDS = {
            temperature: 40,
            humidity: 90,
            accel_x: 2.5,
            accel_y: 2.5,
            accel_z: 12.0,
            gyro_x: 500,
            gyro_y: 500,
            gyro_z: 500,
            soil_moisture: 80, 
            rain_status: 0.5,  
            vibration: 0.5     
        };

        const SECONDS_TO_AVERAGE = 10;
        
        // This file no longer needs to run the rain duration calculation as it's been moved 
        // to index.html to update the live dashboard directly. The functions here are 
        // retained for historical plotting and averaging.

        function averageData(data) {
            const averagedData = {};
            // Updated keys to match all 11 sensor fields (snake_case)
            const keys = ['temperature', 'humidity', 'accel_x', 'accel_y', 'accel_z', 'gyro_x', 'gyro_y', 'gyro_z', 'soil_moisture', 'rain_status', 'vibration'];

            keys.forEach(key => {
                averagedData[key] = [];
            });
            averagedData.labels = [];

            if (data.length === 0) return averagedData;

            let bucketStartTimestamp = new Date(data[0].timestamp).getTime();
            let bucket = [];

            data.forEach(reading => {
                const readingTime = new Date(reading.timestamp).getTime();
                
                if (readingTime - bucketStartTimestamp < SECONDS_TO_AVERAGE * 1000) {
                    bucket.push(reading);
                } else {
                    if (bucket.length > 0) {
                        const averagedReading = keys.reduce((acc, key) => {
                            const sum = bucket.reduce((s, r) => s + r[key], 0);
                            acc[key] = sum / bucket.length;
                            return acc;
                        }, {});

                        keys.forEach(key => {
                            averagedData[key].push({
                                x: new Date(bucketStartTimestamp),
                                y: averagedReading[key]
                            });
                        });
                        averagedData.labels.push(new Date(bucketStartTimestamp).toLocaleTimeString());
                    }

                    bucket = [reading];
                    bucketStartTimestamp = readingTime;
                }
            });

            // Process the last bucket
            if (bucket.length > 0) {
                const averagedReading = keys.reduce((acc, key) => {
                    const sum = bucket.reduce((s, r) => s + r[key], 0);
                    acc[key] = sum / bucket.length;
                    return acc;
                }, {});

                keys.forEach(key => {
                    averagedData[key].push({
                        x: new Date(bucketStartTimestamp),
                        y: averagedReading[key]
                    });
                });
                averagedData.labels.push(new Date(bucketStartTimestamp).toLocaleTimeString());
            }

            return averagedData;
        }
        
        function createChart(canvasId, label, data, borderColor, backgroundColor, threshold, isInverse = false) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            let backgroundColors = data.map(point => {
                if (isInverse) {
                    // If inverse, use red if value is BELOW the critical threshold
                    return point.y < threshold ? 'rgba(255, 99, 132, 0.5)' : backgroundColor;
                } else {
                    // If normal, use red if value is ABOVE the critical threshold (using absolute for accel/gyro)
                    const valueToCheck = label.includes('Accel') || label.includes('Gyro') ? Math.abs(point.y) : point.y;
                    return valueToCheck > threshold ? 'rgba(255, 99, 132, 0.5)' : backgroundColor;
                }
            });

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(p => p.x.toLocaleTimeString()),
                    datasets: [{
                        label: label,
                        data: data.map(p => p.y),
                        borderColor: borderColor,
                        backgroundColor: backgroundColor,
                        pointBackgroundColor: backgroundColors,
                        pointRadius: 5,
                        pointHoverRadius: 8,
                        fill: false,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Sensor Value'
                            },
                            beginAtZero: false 
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Main function to fetch data and create charts
        async function fetchAndPlotHistory() {
            try {
                const response = await fetch('/api/history');
                const rawData = await response.json();
                const averagedData = averageData(rawData);

                // Plot all 11 charts (using new snake_case keys and units)
                createChart('temperatureChart', 'Temperature (Â°C)', averagedData.temperature, 'rgb(255, 99, 132)', 'rgba(255, 99, 132, 0.5)', THRESHOLDS.temperature);
                createChart('humidityChart', 'Humidity (%)', averagedData.humidity, 'rgb(54, 162, 235)', 'rgba(54, 162, 235, 0.5)', THRESHOLDS.humidity);
                
                // Soil Moisture is now percentage (Normal logic: high value is critical)
                createChart('soil_moistureChart', 'Soil Moisture (%)', averagedData.soil_moisture, 'rgb(153, 102, 255)', 'rgba(153, 102, 255, 0.5)', THRESHOLDS.soil_moisture, false);
                // Rain Status is digital (Normal logic: high value is critical)
                createChart('rain_statusChart', 'Rain Status (Digital)', averagedData.rain_status, 'rgb(75, 192, 192)', 'rgba(75, 192, 192, 0.5)', THRESHOLDS.rain_status, false);
                // Vibration is digital (Normal logic: high value is critical)
                createChart('vibrationChart', 'Vibration (Digital)', averagedData.vibration, 'rgb(255, 200, 100)', 'rgba(255, 200, 100, 0.5)', THRESHOLDS.vibration, false);
                
                // Acceleration readings (snake_case in data and label)
                createChart('accel_xChart', 'Acceleration X (g)', averagedData.accel_x, 'rgb(255, 159, 64)', 'rgba(255, 159, 64, 0.5)', THRESHOLDS.accel_x);
                createChart('accel_yChart', 'Acceleration Y (g)', averagedData.accel_y, 'rgb(255, 205, 86)', 'rgba(255, 205, 86, 0.5)', THRESHOLDS.accel_y);
                createChart('accel_zChart', 'Acceleration Z (g)', averagedData.accel_z, 'rgb(102, 255, 102)', 'rgba(102, 255, 102, 0.5)', THRESHOLDS.accel_z);

                // Gyroscope readings (snake_case in data and label)
                createChart('gyro_xChart', 'Gyroscope X (dps)', averagedData.gyro_x, 'rgb(255, 99, 200)', 'rgba(255, 99, 200, 0.5)', THRESHOLDS.gyro_x);
                createChart('gyro_yChart', 'Gyroscope Y (dps)', averagedData.gyro_y, 'rgb(150, 150, 255)', 'rgba(150, 150, 255, 0.5)', THRESHOLDS.gyro_y);
                createChart('gyro_zChart', 'Gyroscope Z (dps)', averagedData.gyro_z, 'rgb(255, 150, 150)', 'rgba(255, 150, 150, 0.5)', THRESHOLDS.gyro_z);


            } catch (error) {
                console.error('Error fetching and plotting data:', error);
            }
        }

        fetchAndPlotHistory();
        // Refresh the charts every minute
        setInterval(fetchAndPlotHistory, 60 * 1000);
    </script>
</body>
</html>